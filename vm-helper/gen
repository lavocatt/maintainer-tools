#!/usr/bin/env python3

import argparse
import shlex
import os
import subprocess
import sys
import json
import tempfile
import time
import pathlib
from datetime import datetime
from contextlib import contextmanager

RESET = "\033[0m"
BOLD = "\033[1m"


class BuildError(RuntimeError):
    pass


class BuildRequestError(BuildError):
    pass


class CacheError(BuildError):
    pass


def send_buil_request(command) -> str:
    p = subprocess.Popen(command, stdout=subprocess.PIPE)
    p.wait()
    output, errors = p.communicate()
    try:
        obj = json.loads(output)
        rid = obj["id"]
        if not rid:
            raise BuildRequestError("Missing request id in answer")
        return rid
    except:
        try:
            raise BuildRequestError(f"Invalid request: {json.dumps(json.loads(output), indent=4)}")
        except BuildRequestError as e:
            raise e
        except:
            if output:
                print(output, file=sys.stderr)
        try:
            raise BuildRequestError(f"Error: {json.dumps(json.loads(errors), indent=4)}")
        except BuildRequestError as e:
            raise e
        except:
            if errors:
                print(errors, file=sys.stderr)
        raise BuildRequestError(f"Error sending build request, check user/"
                                "password, token or network connectivity or vpn..\n")


def wait_build(command):
    last_status = ""
    while True:
        time.sleep(2)
        obj = json.loads(subprocess.check_output(command))
        if "image_status" in obj:
            if "error" in obj["image_status"]:
                raise BuildError(f"Build failed!\n{json.dumps(obj,indent=4)}")
            if obj["image_status"].get("status") in ['success', 'failure']:
                if "upload_status" in obj["image_status"]:
                    print("\n")
                    if obj["image_status"]["upload_status"].get("status") == "success":
                        return obj["image_status"]["upload_status"]["options"]["url"]
                    else:
                        raise BuildError(f"Build failed!\n{json.dumps(obj,indent=4)}")
            else:
                if obj["image_status"].get("status") != last_status:
                    last_status = obj["image_status"].get("status")
                    print(f"\n    * {obj['image_status'].get('status')} .", end="", flush=True)
                else:
                    print(".", end="", flush=True)


def prod_send_build_request(token, request):
    return send_buil_request(["curl",
                              "-H", f'Authorization: Bearer {token}',
                              "-d", f'@{request}',
                              "-X", "POST",
                              "-H", 'Content-Type: application/json',
                              "https://console.redhat.com/api/image-builder/v1/compose",
                              "-s"
                              ])


def prod_wait_build(token, request_id):
    return wait_build(["curl",
                       "-H",
                       f'Authorization: Bearer {token}',
                       "-H",
                       'Content-Type: application/json',
                       f"https://console.redhat.com/api/image-builder/v1/composes/{request_id}",
                       "-s"
                       ])


def stage_send_build_request(username, password, request):
    return send_buil_request(["curl",
                              "--user", f"{username}:{password}",
                              "--proxy", "http://squid.corp.redhat.com:3128",
                              "-d", f'@{request}',
                              "-X", "POST",
                              "-H", 'Content-Type: application/json',
                              "https://console.stage.redhat.com/api/image-builder/v1/compose",
                              "-s"
                              ])


def stage_wait_build(username, password, request_id):
    return wait_build(["curl",
                      "--user", f"{username}:{password}",
                       "--proxy", "http://squid.corp.redhat.com:3128",
                       "-H", 'Content-Type: application/json',
                       f"https://console.stage.redhat.com/api/image-builder/v1/composes/{request_id}",
                       "-s"
                       ])


def get_prod_image_url(offline_token, request):
    """
    Request a build on prod environment requires a valid offline token
    """
    def short_lived_token(token):
        command = ["curl",
                   "https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token",
                   "-d",
                   "grant_type=refresh_token",
                   "-d",
                   "client_id=rhsm-api",
                   "-d",
                   f"refresh_token={token}",
                   "-s"]
        obj = json.loads(subprocess.check_output(command))
        return obj["access_token"]
    token = short_lived_token(offline_token)
    # Send build request
    request_id = prod_send_build_request(token, request)

    # wait until it's built
    url = prod_wait_build(token, request_id)
    return url


def get_stage_image_url(username, password, request):
    """
    Request a build on stage environment requires a valid username and password
    """
    # Send build request
    request_id = stage_send_build_request(username, password, request)
    if not request_id:
        raise RuntimeError("No request id, check errors")

    # wait until it's built
    url = stage_wait_build(username, password, request_id)
    if not url:
        raise RuntimeError("No URL to download from")
    return url


def get_cache_dir():
    # check if local cache exists if not create it
    cache_dir = os.path.join(os.path.expanduser("~/.cache"), "vm-helper")
    if not os.path.isdir(cache_dir):
        os.mkdir(cache_dir)
    return cache_dir


@contextmanager
def make_request_file(distribution, name, architecture, packages, stage,
                      activation_key=None, organization=None, insights=True):
    """
    Yields a request file
    """
    with tempfile.TemporaryDirectory() as tmpdirname:
        request_file = os.path.join(tmpdirname, "request.json")
        with open(request_file, "w") as r:
            request = {
                "distribution": distribution,
                "image_name": name,
                "image_requests": [
                    {
                        "architecture": architecture,
                        "image_type": "guest-image",
                        "upload_request": {
                            "type": "aws.s3",
                            "options": {}
                        }
                    }
                ],
                "customizations": {
                    "packages": packages
                },
            }
            serverurl = "subscription.rhsm.redhat.com"
            baseurl = "https://cdn.redhat.com/"
            if stage:
                serverurl = "subscription.rhsm.stage.redhat.com"
                baseurl = "https://cdn.stage.redhat.com/"
            if activation_key:
                request["customizations"]["subscription"] = {
                    "activation-key": activation_key,
                    "insights": insights,
                    "organization": organization,
                    "server-url": serverurl,
                    "base-url": baseurl
                }
            json.dump(request, r)
        try:
            yield request_file
        except Exception as e:
            raise e
        finally:
            os.remove(request_file)


def download(url, destination):
    """
    Downloads an url as a destination
    """
    print("Downloading:")
    command = ["curl",
               url,
               "-o",
               destination]
    return subprocess.check_output(command)


def get_password(args):
    if args.password:
        return args.password
    elif args.password_command:
        command = shlex.split(args.password_command)
        return subprocess.check_output(command).decode("utf-8").replace("\n", "")
    raise RuntimeError("no password!")


def get_offline_token(args):
    if args.offline_token:
        return args.offline_token
    elif args.offline_token_command:
        command = shlex.split(args.offline_token_command)
        return subprocess.check_output(command).decode("utf-8").replace("\n", "")


def create_metadata(request, path, filename, args):
    with open(request, "r") as in_:
        req = json.load(in_)
        with open(path, "w") as out:
            json.dump({
                "request": req,
                "filename": filename,
                "platform": args.command,
                "date": datetime.now().timestamp()
            }, out)

def print_cache_entry(entry, indent=4):
    content = (f"filename:\t{entry['filename']}:\n"
    f"created at:\t{datetime.fromtimestamp(entry['date'])}\n"
    f"platform:\t{entry['platform']}\n"
    f"request:\t{json.dumps(entry['request'], indent=4)}")
    for line in content.split("\n"):
        print(" "*indent, line)

@contextmanager
def generate_image(args):
    # Check if we need to return an object from the cache instead of building it
    cache_dir = get_cache_dir()
    source = args.command
    filemetadata = f"{args.name}_{args.distribution}_{args.architecture}_{source}.json"
    filename = f"{args.name}_{args.distribution}_{args.architecture}_{source}.qcow2"

    # Check if image is in cache
    cache_path = os.path.join(cache_dir, filename)
    if not args.no_from_cache and os.path.exists(cache_path):
        if not args.batch:
            print("    Found entry in cache:")
            with open(os.path.join(get_cache_dir(), filemetadata), 'r') as f:
                print_cache_entry(json.load(f), 8)
            v = input(f"    L(Load) r(Regenerate) a(Abort):")
            if v == "a":
                sys.exit(0)
            if v == "" or v.upper() == "L":
                yield cache_path
                return
            elif v.upper() == "R":
                os.remove(cache_path)
            else:
                raise CacheError("Invalid answer")
        else:
            input("    Found image in cache")
            yield cache_path
            return

    print()
    print("Building:")
    print()
    print("    Generating image with parameters:\n")
    print(f"        Image name {args.name}")
    print(f"        Distribution {args.distribution}")
    print(f"        Architecture {args.architecture}")
    print(f"        Packages {args.packages}")
    print(f"        Keep in cache {not args.no_keep}")
    print(f"        Source {source}")
    print(f"        Activation key {args.activation_key}")
    print(f"        Organization key {args.organization}")
    print()

    # Download the image, either in cache or in a tmp folder
    if not args.no_keep:
        dl_dir = cache_dir
    else:
        dl_dir = tempfile.mkdtemp()

    # Generate the image
    url = None
    with make_request_file(args.distribution, args.name,
                           args.architecture, args.packages,
                           args.command == "stage", args.activation_key,
                           args.organization) as request:
        if args.command == "stage":
            url = get_stage_image_url(
                args.username,
                get_password(args),
                request
            )
        else:
            url = get_prod_image_url(
                get_offline_token(args),
                request
            )

        destination = os.path.join(dl_dir, filename)
        try:
            download(url, destination)
            if not args.no_keep:
                create_metadata(request, os.path.join(dl_dir, filemetadata),
                                filename, args)
            yield destination
        except Exception as e:
            raise e
        finally:
            if args.no_keep:
                # clean the temporary dir
                os.remove(destination)
                os.rmdir(dl_dir)


def main():
    gen_parser = argparse.ArgumentParser(description='Generates, downloads and runs '
                                         'an image to run')

    # Build options
    build_mode = False
    if "stage" in sys.argv or "prod" in sys.argv:
        build_mode = True

    gen_parser.add_argument("--name",
                            required=build_mode,
                            type=str,
                            help="Image name"
                            )
    gen_parser.add_argument("--distribution",
                            required=build_mode,
                            type=str,
                            choices=[
                                "centos-8",
                                "centos-9",
                                "fedora-34",
                                "fedora-35",
                                "fedora-36",
                                "fedora-37",
                                "rhel-84",
                                "rhel-85",
                                "rhel-86",
                                "rhel-87",
                                "rhel-88",
                                "rhel-90",
                                "rhel-91",
                                "rhel-92",
                            ],
                            help="The distribution to generate"
                            )
    gen_parser.add_argument("--architecture",
                            required=build_mode,
                            type=str,
                            choices=[
                                "x86_64",
                                "aarch64",
                                "s390x",
                                "ppc64le"],
                            help="The architecture to generate"
                            )
    gen_parser.add_argument("--packages",
                            nargs='+',
                            type=str,
                            default=[],
                            help="The packages to install"
                            )
    gen_parser.add_argument("--activation-key",
                            type=str,
                            required="--organization" in sys.argv,
                            help="The activation key for subscription manager."
                            " Needs to be used with --organization"
                            )
    gen_parser.add_argument("--organization",
                            required="--activation-key" in sys.argv,
                            type=int,
                            help="The organization id for subscription manager."
                            " Needs to be used with --activation_key"
                            )

    # Cache options
    gen_parser.add_argument("--no-keep",
                            default=False,
                            action="store_true",
                            help="Don't keep the image in cache after download")
    gen_parser.add_argument("--no-from-cache",
                            default=False,
                            action="store_true",
                            help="Don't load from the cache instead build it")
    gen_parser.add_argument("--batch",
                            default=False,
                            action="store_true",
                            help="Don't ask questions, just load from cache")

    subparsers = gen_parser.add_subparsers(title="command",
                                           required=True,
                                           dest='command',
                                           help='Command to execute')

    stage_parser = subparsers.add_parser("stage", help="generates on stage")
    prod_parser = subparsers.add_parser("prod", help="generates on prod")
    list_parser = subparsers.add_parser("list", help="list cache content")
    # Needs an offline token only if we're on prod
    group = prod_parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--offline-token",
                       type=str,
                       help="Offline token provided by https://access.redhat.com/management/api"
                       )
    group.add_argument("--offline-token-command",
                       default="pass offline_token",
                       type=str,
                       help="Command to retrieve the offline token"
                       )
    # Otherwise, needs ethel user and password
    stage_parser.add_argument("--username",
                              required="--stage" in sys.argv,
                              type=str,
                              help="Ethel username"
                              )
    group = stage_parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--password",
                       type=str,
                       help="Ethel password"
                       )
    group.add_argument("--password-command",
                       default="pass ethel_password",
                       type=str,
                       help="Command to retrieve the ethel password"
                       )

    # VM extra options
    gen_parser.add_argument("--vm-args",
                            type=str,
                            default="",
                            help="Extra args for the vm executable, if none"
                            "given, will infer what is needed"
                            )

    args = gen_parser.parse_args()

    if args.command == "list":
        print("Cache content:")
        for i, file in enumerate(os.listdir(get_cache_dir())):
            if pathlib.Path(file).suffix == ".json":
                with open(os.path.join(get_cache_dir(), file), 'r') as f:
                    entry = json.load(f)
                    print(f"Entry #{i} ---")
                    print_cache_entry(entry)
        return

    print("Generation:")
    try:
        with generate_image(args) as image:
            print("\nRunning:\n")
            subprocess.run(
                [os.path.join(os.path.dirname(__file__), "vm")] +
                shlex.split(args.vm_args) +
                [image, args.architecture]
            )
    except BuildError as e:
        print(e)
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
